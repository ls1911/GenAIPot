{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udd36\ud83c\udd34\ud83c\udd3d\ud83c\udd30\ud83c\udd38\ud83c\udd3f\ud83c\udd3e\ud83c\udd43","text":"<p>GenAIPot is the first A.I honeypot that emulates services and using Generative AI to do that in order to be more stealth.</p> <p>It uses various AI services to generate realistic responses to both POP3 and SMTP commands, logs all interactions to an SQLite database, and provides capabilities for anomaly detection and predictions using machine learning.</p>"},{"location":"#overview","title":"Overview","text":"<p>GenAIPot contains a custom implementation of the Post Office Protocol version 3 (POP3) and Simple Mail Transfer Protocol (SMTP) using Twisted framework in Python.</p> <p>It supports standard email operations such as user authentication, email retrieval, deletion, and session termination.</p> <p>It integrates AI-generated responses to provide dynamic and customizable email content and interactions. Additionally, the server includes analytics capabilities for monitoring and anomaly detection.</p> <p>This app is not meant to be used in production systems , if you do, do it at your own risk.</p> <p>GenAIPot created by Nucleon Cyber (www.nucleon.sh) as part of its advanced Adversary Generated Threat Intelligence (AGTI) platform.  If you wish to use this version or more advanced versions in production settings or if you want to hear more about the most advanced AGTI platform, you welcome to contact the project admins</p>"},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing the software, ensure that your system meets the following prerequisites:</p> <ol> <li> <p>Python Version: Ensure Python 3.7 or later is installed. You can download it from python.org.</p> </li> <li> <p>pip: The package installer for Python. It usually comes with Python, but if not, you can install it separately.</p> </li> <li> <p>Virtual Environment: It's recommended to use a virtual environment to manage dependencies. You can use <code>venv</code> or <code>virtualenv</code>.</p> </li> <li> <p>Git: If you want to clone the repository, make sure Git is installed. Download from git-scm.com.</p> </li> </ol>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":""},{"location":"installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<p>If you haven't done so already, clone the repository to your local machine:</p> <pre><code>git clone https://github.com/your-username/your-repo.git\ncd your-repo\n</code></pre> <p>2. Set Up a Virtual Environment</p> <p>Create a virtual environment to manage dependencies:</p> <pre><code>python -m venv venv\n</code></pre> <p>Activate the virtual environment:</p> <p>\u2022  On Windows:</p> <pre><code>venv\\Scripts\\activate\n</code></pre> <p>\u2022  On macOS and Linux:</p> <pre><code>source venv/bin/activate\n</code></pre> <p>3. Install Dependencies</p> <p>Install the required Python packages using pip:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>4. Configuration</p> <p>Create a configuration file or run the app with --config</p> <pre><code>python3 main.py --config\n</code></pre> <p>Dont forget to configure OpenAI keys in the config.ini file if you want to use AI</p>"},{"location":"usage/","title":"Usage","text":"<p>Start the application using:</p> <p>POP3 Server Only</p> <pre><code>python3 main.py --pop3\n</code></pre> <p>SMTP Server Only</p> <pre><code>python3 main.py --smtp\n</code></pre> <p>Both protocols</p> <pre><code>python3 main.py --all\n</code></pre>"},{"location":"usage/#docker","title":"Docker","text":"<p>you can download the latest docker image or you can build yourself, to build yourself use, the docker image will first run the config wizard and afterwards starts both protocols</p> <pre><code>docker build . -t genaipot\ndocker run -p25:25 110:110 genaipot\n</code></pre>"},{"location":"reference/ai_services/","title":"AI Services","text":""},{"location":"reference/ai_services/#aiservice-class","title":"AIService Class","text":""},{"location":"reference/ai_services/#ai_services.AIService","title":"<code>ai_services.AIService</code>","text":"Source code in <code>src/ai_services.py</code> <pre><code>class AIService:\n    def __init__(self, debug_mode=False):\n        self.technology = config.get('server', 'technology', fallback='generic')\n        self.domain = config.get('server', 'domain', fallback='localhost')\n        self.segment = config.get('server', 'segment', fallback='general')\n        self.anonymous_access = config.getboolean('server', 'anonymous_access', fallback=False)\n\n        if not config.has_section('openai'):\n            config.add_section('openai')\n            print (\"no\")\n\n        openai.api_key = config['openai']['api_key']\n        self.debug_mode = debug_mode\n\n        if self.debug_mode:\n            logging.getLogger('ai_services').setLevel(logging.DEBUG)\n            logging.getLogger('urllib3').setLevel(logging.DEBUG)\n        else:\n            logging.getLogger('ai_services').setLevel(logging.CRITICAL)  # Suppress errors in non-debug mode\n            logging.getLogger('urllib3').setLevel(logging.CRITICAL)\n\n    def query_responses(self, prompt, response_type):\n        for attempt in range(2):\n            try:\n                if self.debug_mode:\n                    logger.debug(f\"Querying OpenAI for {response_type} responses...\")\n                response = openai.ChatCompletion.create(\n                    model=\"gpt-4\",\n                    messages=[\n                        {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n                        {\"role\": \"user\", \"content\": prompt}\n                    ],\n                    max_tokens=500\n                )\n                response_text = response.choices[0]['message']['content'].strip()\n                self._save_raw_response(response_text, response_type)\n                return response_text\n            except Exception as e:\n                if self.debug_mode:\n                    logger.error(f\"Error querying OpenAI (attempt {attempt+1}/2): {e}\")\n                if attempt == 1:\n                    logger.critical(\"Failed to communicate with AI after 2 attempts. Exiting.\")\n                    exit(1)\n                time.sleep(1)\n\n    def _save_raw_response(self, response_text, response_type):\n        filename = f'files/{response_type}_raw_response.txt'\n        with open(filename, 'w') as f:\n            f.write(response_text)\n        if self.debug_mode:\n            logger.debug(f\"Raw response saved in {filename}\")\n\n    def _store_responses(self, responses, response_type):\n        filename = f'files/{response_type}_responses.json'\n        with open(filename, 'w') as f:\n            json.dump(responses, f)\n        if self.debug_mode:\n            logger.debug(f\"Responses stored in {filename}\")\n\n    def load_responses(self, response_type):\n        filename = f'files/{response_type}_raw_response.txt'\n        if os.path.exists(filename):\n            with open(filename, 'r') as f:\n                return f.read()\n        return \"No responses available\"\n\n    def cleanup_and_parse_json(self, text):\n        try:\n            start = text.find('{')\n            end = text.rfind('}') + 1\n            if start == -1 or end == 0:\n                if self.debug_mode:\n                    logger.error(\"Invalid JSON structure detected.\")\n                    logger.debug(f\"Raw text: {text}\")\n                return {}\n\n            json_text = text[start:end]\n            return json.loads(json_text)\n        except json.JSONDecodeError as e:\n            if self.debug_mode:\n                logger.error(f\"Error parsing JSON response: {e}\")\n                logger.debug(f\"Raw text for cleanup: {text}\")\n            return {}\n\n    def generate_emails(self, segment, domain, email_num):\n        try:\n            prompt = (\n                f\"Generate an email related to the segment: {segment} for the domain {domain}. \"\n                f\"The email should include a subject, body, and a recipient address at the domain.\"\n            )\n            response = openai.ChatCompletion.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ],\n                max_tokens=500\n            )\n            response_text = response.choices[0]['message']['content'].strip()\n\n            # Save the raw response to a file\n            filename = f'files/email{email_num}_raw_response.txt'\n            with open(filename, 'w') as f:\n                f.write(response_text)\n            if self.debug_mode:\n                logger.debug(f\"Raw response saved in {filename}\")\n\n            return response_text\n        except Exception as e:\n            if self.debug_mode:\n                logger.error(f\"Error querying OpenAI for email {email_num}: {e}\")\n            return \"No response\"\n\n    def save_email_responses(self, responses, email_num):\n        \"\"\"\n        Save the cleaned email responses to a file.\n\n        Args:\n            responses (dict): The responses to save.\n            email_num (int): The email number identifier.\n        \"\"\"\n        filename = f'files/email_email{email_num}.json'\n        with open(filename, 'w') as f:\n            json.dump(responses, f)\n        if self.debug_mode:\n            logger.debug(f\"Email {email_num} response stored in {filename}\")\n\n    def update_config_technology(self, technology):\n        config.set('server', 'technology', technology)\n        with open('config.ini', 'w') as configfile:\n            config.write(configfile)\n        if self.debug_mode:\n            logger.debug(f\"Config file updated with technology: {technology}\")\n\n    def update_config_segment(self, segment):\n        config.set('server', 'segment', segment)\n        with open('config.ini', 'w') as configfile:\n            config.write(configfile)\n        if self.debug_mode:\n            logger.debug(f\"Config file updated with segment: {segment}\")\n\n    def update_config_domain(self, domain):\n        config.set('server', 'domain', domain)\n        with open('config.ini', 'w') as configfile:\n            config.write(configfile)\n        if self.debug_mode:\n            logger.debug(f\"Config file updated with domain: {domain}\")\n\n    def update_config_anonymous_access(self, anonymous_access):\n        config.set('server', 'anonymous_access', str(anonymous_access))\n        with open('config.ini', 'w') as configfile:\n            config.write(configfile)\n        if self.debug_mode:\n            logger.debug(f\"Config file updated with anonymous access: {anonymous_access}\")\n</code></pre>"},{"location":"reference/ai_services/#ai_services.AIService.save_email_responses","title":"<code>save_email_responses(responses, email_num)</code>","text":"<p>Save the cleaned email responses to a file.</p> <p>Parameters:</p> Name Type Description Default <code>responses</code> <code>dict</code> <p>The responses to save.</p> required <code>email_num</code> <code>int</code> <p>The email number identifier.</p> required Source code in <code>src/ai_services.py</code> <pre><code>def save_email_responses(self, responses, email_num):\n    \"\"\"\n    Save the cleaned email responses to a file.\n\n    Args:\n        responses (dict): The responses to save.\n        email_num (int): The email number identifier.\n    \"\"\"\n    filename = f'files/email_email{email_num}.json'\n    with open(filename, 'w') as f:\n        json.dump(responses, f)\n    if self.debug_mode:\n        logger.debug(f\"Email {email_num} response stored in {filename}\")\n</code></pre>"},{"location":"reference/auth/","title":"Authentication Module","text":""},{"location":"reference/auth/#authentication-functions","title":"Authentication Functions","text":""},{"location":"reference/auth/#auth","title":"<code>auth</code>","text":""},{"location":"reference/auth/#auth.check_credentials","title":"<code>check_credentials(username, password)</code>","text":"<p>Check if the provided credentials match the stored credentials.</p> Source code in <code>src/auth.py</code> <pre><code>def check_credentials(username, password):\n    \"\"\"\n    Check if the provided credentials match the stored credentials.\n    \"\"\"\n    stored_username = config.get('server', 'username')\n    stored_password = config.get('server', 'password')  # This is the hashed password\n\n    # Hash the provided password to compare with stored hash\n    hashed_password = hash_password(password)\n\n    if config.getboolean('server', 'debug', fallback=False):\n        logger.debug(f\"Checking credentials for user: {username}\")\n        logger.debug(f\"Provided password (hashed): {hashed_password}\")\n        logger.debug(f\"Stored username: {stored_username}\")\n        logger.debug(f\"Stored password (hashed): {stored_password}\")\n\n    if username == stored_username and hashed_password == stored_password:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/auth/#auth.hash_password","title":"<code>hash_password(password)</code>","text":"<p>Hash the provided password using a secure hashing algorithm.</p> Source code in <code>src/auth.py</code> <pre><code>def hash_password(password):\n    \"\"\"\n    Hash the provided password using a secure hashing algorithm.\n    \"\"\"\n    return hashlib.sha256(password.encode()).hexdigest()\n</code></pre>"},{"location":"reference/main/","title":"Main","text":""},{"location":"reference/main/#genaipot","title":"<code>genaipot</code>","text":""},{"location":"reference/main/#genaipot.ensure_files_directory","title":"<code>ensure_files_directory()</code>","text":"<p>Ensure the existence of the 'files' directory.</p> Source code in <code>bin/genaipot.py</code> <pre><code>def ensure_files_directory():\n    \"\"\"Ensure the existence of the 'files' directory.\"\"\"\n    if not os.path.exists('files'):\n        os.makedirs('files')\n</code></pre>"},{"location":"reference/main/#genaipot.main","title":"<code>main()</code>","text":"<p>Main function to run the GenAIPot honeypot services.</p> Source code in <code>bin/genaipot.py</code> <pre><code>def main():\n    \"\"\"Main function to run the GenAIPot honeypot services.\"\"\"\n    ensure_files_directory()\n\n    # Set up the database\n    setup_database()\n\n    Art = art.text2art(\"GenAIPot\")\n    print(Art)\n    print (\"---------------------------------------\")\n    a=f\"Version: {VERSION}\"\n    spinner = Halo(text=a, spinner='dots')    \n    spinner.succeed()\n    #spinner.stop_and_persist()\n    spinner = Halo(text=\"The first Generative A.I Honeypot\", spinner='dots')\n\n    spinner.stop_and_persist(symbol='\ud83e\udd84'.encode('utf-8'))\n\n    if args.config:\n        run_config_wizard()\n        return\n\n    # Check for the presence of an OpenAI API key or 'no_ai' setting\n    api_key = config.get('openai', 'api_key', fallback='')\n\n    if api_key == 'no_ai':\n        print(\"Using default templates as no valid A.I key is set.\")\n    elif not validate_openai_key(api_key):\n        print(\"No valid A.I key found. Please run the configuration wizard to set up the necessary key.\")\n        run_config_wizard()\n        return\n\n    if args.smtp or args.pop3 or args.all:\n        try:\n            print (\"\\n\")\n            logger.info(f\"Starting GenAIPot Version {VERSION}\")\n            if args.debug:\n                start_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                logger.info(f\"Start Time: {start_time}\")\n                logger.info(f\"IP: {config.get('server', 'ip', fallback='localhost')}\")\n                logger.info(f\"Listening Ports: {', '.join(['25', '110']) if args.all else ('25' if args.smtp else '110')}\")\n                logger.info(f\"SQLite Logging Enabled: {config.getboolean('logging', 'sqlite', fallback=True)}\")\n                logger.info(f\"Server Technology: {config.get('server', 'technology', fallback='generic')}\")\n                logger.info(f\"Domain Name: {config.get('server', 'domain', fallback='localhost')}\")\n                logging.getLogger('urllib3').setLevel(logging.DEBUG)\n\n            if args.smtp or args.all:\n                smtp_factory = SMTPFactory()\n                reactor.listenTCP(25, smtp_factory)\n                logger.info(\"SMTP honeypot started on port 25\")\n\n            if args.pop3 or args.all:\n                pop3_factory = POP3Factory(debug=args.debug)\n                reactor.listenTCP(110, pop3_factory)\n                logger.info(\"POP3 honeypot started on port 110\")\n\n            logger.info(\"Reactor is running...\")\n            reactor.run()\n        except Exception as e:\n            logger.error(f\"Failed to start honeypot: {e}\")\n\n    else:\n        parser.print_help()\n</code></pre>"},{"location":"reference/main/#genaipot.query_ai_service_for_responses","title":"<code>query_ai_service_for_responses(technology, segment, domain, anonymous_access, debug_mode)</code>","text":"<p>Query the AI service for SMTP and POP3 responses and sample emails.</p> <p>Parameters:</p> Name Type Description Default <code>technology</code> <code>str</code> <p>The technology used (e.g., sendmail, exchange).</p> required <code>segment</code> <code>str</code> <p>The segment of the industry or application.</p> required <code>domain</code> <code>str</code> <p>The domain name for the service.</p> required <code>anonymous_access</code> <code>bool</code> <p>Whether anonymous access is allowed.</p> required <code>debug_mode</code> <code>bool</code> <p>Whether to enable debug mode.</p> required Source code in <code>bin/genaipot.py</code> <pre><code>def query_ai_service_for_responses(technology, segment, domain, anonymous_access, debug_mode):\n    \"\"\"\n    Query the AI service for SMTP and POP3 responses and sample emails.\n\n    Args:\n        technology (str): The technology used (e.g., sendmail, exchange).\n        segment (str): The segment of the industry or application.\n        domain (str): The domain name for the service.\n        anonymous_access (bool): Whether anonymous access is allowed.\n        debug_mode (bool): Whether to enable debug mode.\n    \"\"\"\n    ai_service = AIService(debug_mode=debug_mode)\n\n\n    # Load prompts from prompts.ini\n    smtp_prompt = prompts.get('Prompts', 'smtp_prompt').format(technology=technology)\n    pop3_prompt = prompts.get('Prompts', 'pop3_prompt').format(technology=technology)\n    email_prompts = [\n        prompts.get('Prompts', 'client_email_prompt').format(segment=segment, domain=domain),\n        prompts.get('Prompts', 'supplier_email_prompt').format(segment=segment, domain=domain),\n        prompts.get('Prompts', 'internal_email_prompt').format(segment=segment, domain=domain)\n    ]\n\n    # Spinner for SMTP responses\n    spinner = Halo(text='SMTP Contacting A.I service and generating responses (1/5)...', spinner='dots')\n    spinner.start()\n    try:\n        smtp_raw_response = ai_service.query_responses(smtp_prompt, \"smtp\")\n        smtp_cleaned_response = ai_service.cleanup_and_parse_json(smtp_raw_response)\n        ai_service._store_responses(smtp_cleaned_response, \"smtp\")\n        spinner.succeed('SMTP responses generated successfully.')\n    except Exception as e:\n        spinner.fail('Failed to generate SMTP responses.')\n\n    # Spinner for POP3 responses\n    spinner = Halo(text='POP3 Contacting A.I service and generating responses (2/5)...', spinner='dots')\n    spinner.start()\n    try:\n        pop3_raw_response = ai_service.query_responses(pop3_prompt, \"pop3\")\n        pop3_cleaned_response = ai_service.cleanup_and_parse_json(pop3_raw_response)\n        ai_service._store_responses(pop3_cleaned_response, \"pop3\")\n        spinner.succeed('POP3 responses generated successfully.')\n    except Exception as e:\n        spinner.fail('\u2716 Failed to generate POP3 responses.')\n\n    # Spinner for sample emails\n    total_emails = len(email_prompts)\n    for i in range(total_emails):\n        spinner = Halo(text=f'Contacting A.I service and generating sample email #{i+1} ({i+3}/5)...', spinner='dots')\n        spinner.start()\n        try:\n            email_raw_response = ai_service.query_responses(email_prompts[i], f\"email{i+1}\")\n            email_cleaned_response = ai_service.cleanup_and_parse_json(email_raw_response)\n            ai_service.save_email_responses(email_cleaned_response, f\"email{i+1}\")\n            spinner.succeed(f'Sample email #{i+1} generated successfully.')\n        except Exception as e:\n            spinner.fail(f'\u2716 Failed to generate sample email #{i+1}.')\n            logger.error(f\"Error generating sample email #{i+1}: {e}\")\n\n    # Update the config file with the technology, segment, domain, and anonymous access\n    config.set('server', 'technology', technology)\n    config.set('server', 'segment', segment)\n    config.set('server', 'domain', domain)\n    config.set('server', 'anonymous_access', str(anonymous_access))\n\n    # Handle user credentials if anonymous access is not allowed\n    if not anonymous_access:\n        username = input(\"Enter username: \")\n        password = input(\"Enter password: \")\n        hashed_password = hash_password(password)\n        config.set('server', 'username', username)\n        config.set('server', 'password', hashed_password)\n    else:\n        if config.has_option('server', 'username'):\n            config.remove_option('server', 'username')\n        if config.has_option('server', 'password'):\n            config.remove_option('server', 'password')\n\n    # Save the updated configuration\n    with open('etc/config.ini', 'w') as configfile:\n        config.write(configfile)\n\n    logger.info(f\"Config file updated with anonymous_access: {anonymous_access}\")\n</code></pre>"},{"location":"reference/main/#genaipot.run_config_wizard","title":"<code>run_config_wizard()</code>","text":"<p>Runs the configuration wizard to set up the honeypot.</p> Source code in <code>bin/genaipot.py</code> <pre><code>def run_config_wizard():\n    \"\"\"Runs the configuration wizard to set up the honeypot.\"\"\"\n\n    spinner = Halo(text=\"Initiating Configuration Wizard\", spinner='dots')\n    spinner.start()\n    spinner.stop_and_persist(symbol='\ud83e\udd84'.encode('utf-8'))\n\n    openai_key = input(\"Enter your OpenAI API key: \")\n\n    # Use Halo spinner for key verification\n    with Halo(text='Verifying A.I key...', spinner='dots') as spinner:\n        if not validate_openai_key(openai_key):\n            spinner.fail(\"A valid key is needed for GenAIPot to function properly.\")\n            use_default = input(\"Do you want to use default template files instead of the A.I service generating them dynamically for you? (y/n): \").lower() == 'y'\n            if not use_default:\n                print(\"Exiting the application. Please provide a valid OpenAI API key.\")\n                exit(1)\n            else:\n                # Copy default files from var/no_ai to files/\n                if not os.path.exists('files'):\n                    os.makedirs('files')\n                for filename in os.listdir('var/no_ai'):\n                    src_path = os.path.join('var/no_ai', filename)\n                    dst_path = os.path.join('files', filename)\n                    shutil.copyfile(src_path, dst_path)\n\n                # Update the config file to reflect the use of default templates\n                #config.set('openai', 'api_key', 'no_ai')\n                #with open('config.ini', 'w') as configfile:\n                #    config.write(configfile)\n\n                shutil.copyfile('var/no_ai/config.ini', 'etc/config.ini')\n                print(\"Default template files have been used.\")\n                return\n\n        spinner.succeed(\"A.I key verified successfully.\")\n\n    technology = input(\"Choose the server technology to emulate:\\n\"\n                       \"1. sendmail\\n\"\n                       \"2. exchange\\n\"\n                       \"3. qmail\\n\"\n                       \"4. postfix\\n\"\n                       \"5. zimbra\\n\"\n                       \"6. other\\n\"\n                       \"Enter the number of your choice: \")\n    technology = {\n        '1': 'sendmail',\n        '2': 'exchange',\n        '3': 'qmail',\n        '4': 'postfix',\n        '5': 'zimbra',\n        '6': 'other'\n    }.get(technology, 'generic')\n\n    segment = input(\"Enter the segment (Description of the industry segment; for example: an international bank located in nome alsaka.): \")\n    domain = input(\"Enter the domain name (name for your fictional company): \")\n    anonymous_access = input(\"Allow anonymous access? (y/n): (if yes, any username will be accepted)\").lower() == 'y'\n\n    # Ask for credentials after the spinner is done\n    if not anonymous_access:\n        username = input(\"Enter username: \")\n        password = input(\"Enter password: \")\n        hashed_password = hash_password(password)\n        config.set('server', 'username', username)\n        config.set('server', 'password', hashed_password)\n    else:\n        if config.has_option('server', 'username'):\n            config.remove_option('server', 'username')\n        if config.has_option('server', 'password'):\n            config.remove_option('server', 'password')\n\n\n\n    with Halo(text='Saving configuration...', spinner='dots') as spinner:\n        # Save the configuration to the config file\n        if not config.has_section('openai'):\n            config.add_section('openai')\n        if not config.has_section('server'):\n            config.add_section('server')\n\n        config.set('openai', 'api_key', openai_key)\n        config.set('server', 'technology', technology)\n        config.set('server', 'segment', segment)\n        config.set('server', 'domain', domain)\n        config.set('server', 'anonymous_access', str(anonymous_access))\n\n        with open('etc/config.ini', 'w') as configfile:\n            config.write(configfile)\n\n        spinner.succeed(\"Configuration has been saved successfully.\")\n\n    logger.info(\"Configuration has been updated.\")\n    print(\"Configuration has been saved.\")\n\n    # Generate responses and sample emails using the AI service\n    query_ai_service_for_responses(technology, segment, domain, anonymous_access, args.debug)\n</code></pre>"},{"location":"reference/main/#genaipot.validate_openai_key","title":"<code>validate_openai_key(api_key)</code>","text":"<p>Validate the OpenAI API key by making a simple API call.</p> Source code in <code>bin/genaipot.py</code> <pre><code>def validate_openai_key(api_key):\n    \"\"\"Validate the OpenAI API key by making a simple API call.\"\"\"\n    openai.api_key = api_key\n    try:\n        # Attempt a simple API request to verify the key\n        openai.Engine.list()\n        spinner = Halo(text=\"API key is valid.\", spinner='dots')\n        spinner.start()\n        spinner.stop_and_persist(symbol='\ud83e\udd84'.encode('utf-8'))\n        print (\"---------------------------------------\")\n        return True\n    except openai.error.AuthenticationError:\n        print(\"Invalid API key. Please enter a valid OpenAI API key.\")\n        return False\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return False\n</code></pre>"},{"location":"reference/smtp_protocol/","title":"SMTP Protocol","text":"<p>This section provides an overview of the <code>SMTPProtocol</code> class and related functionality implemented in the <code>smtp_protocol.py</code> file. It describes how the SMTP protocol is handled, including command parsing, response formatting, and state management.</p>"},{"location":"reference/smtp_protocol/#smtpprotocol-class","title":"SMTPProtocol Class","text":"<p>The <code>SMTPProtocol</code> class manages the state and communication for the SMTP protocol. It is responsible for handling SMTP commands, managing session states, and generating appropriate responses.</p>"},{"location":"reference/smtp_protocol/#smtp_protocol.SMTPProtocol","title":"<code>smtp_protocol.SMTPProtocol</code>","text":"<p>               Bases: <code>LineReceiver</code></p> <p>A class representing the SMTP protocol for handling email transmission commands and responses.</p> <p>Attributes:</p> Name Type Description <code>ip</code> <code>str</code> <p>The IP address of the connected client.</p> <code>ai_service</code> <code>AIService</code> <p>An instance of the AIService for loading and managing responses.</p> <code>responses</code> <code>dict</code> <p>A dictionary of SMTP responses loaded from the AI service.</p> <code>state</code> <code>str</code> <p>The current state of the protocol, used to manage the flow of commands (e.g., INITIAL, DATA).</p> <code>data_buffer</code> <code>list</code> <p>A buffer for storing lines of data received during the DATA state.</p> Source code in <code>src/smtp_protocol.py</code> <pre><code>class SMTPProtocol(LineReceiver):\n    \"\"\"\n    A class representing the SMTP protocol for handling email transmission commands and responses.\n\n    Attributes:\n        ip (str): The IP address of the connected client.\n        ai_service (AIService): An instance of the AIService for loading and managing responses.\n        responses (dict): A dictionary of SMTP responses loaded from the AI service.\n        state (str): The current state of the protocol, used to manage the flow of commands (e.g., INITIAL, DATA).\n        data_buffer (list): A buffer for storing lines of data received during the DATA state.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the SMTPProtocol instance, setting up AI services and responses.\n        \"\"\"\n        self.ip = None\n        self.ai_service = AIService()\n        responses = self.ai_service.load_responses(\"smtp\")\n        logger.debug(f\"Loaded responses: {responses}\")\n        self.responses = self._format_responses(responses)\n        self.state = 'INITIAL'\n        self.data_buffer = []\n        logger.debug(\"SMTPProtocol initialized\")\n\n    def connectionMade(self):\n        \"\"\"\n        Handle new connections, sending a welcome banner and logging the interaction.\n        \"\"\"\n        self.ip = self.transport.getPeer().host\n        banner = self._get_banner()\n        logger.info(f\"Connection from {self.ip}\")\n        self.sendLine(banner.encode('utf-8'))\n        log_interaction(self.ip, 'WELCOME', banner)\n\n    def _get_banner(self):\n        \"\"\"\n        Get the SMTP banner message to send upon connection.\n\n        Returns:\n            str: The banner message based on the server technology.\n        \"\"\"\n        if technology.lower() == 'exchange':\n            current_date = datetime.now().strftime(\"%a, %d %b %Y %H:%M:%S %z\")\n            return f\"220 {domain_name} Microsoft ESMTP MAIL Service ready at {current_date}\"\n        return self.responses.get(\"220\", f\"220 {domain_name} ESMTP\")\n\n    def lineReceived(self, line):\n        \"\"\"\n        Handle received lines of data, processing SMTP commands and managing state transitions.\n\n        Args:\n            line (bytes): The line of data received.\n        \"\"\"\n        try:\n            command = line.decode('utf-8').strip()\n            logger.info(f\"Received command: {command}\")\n\n            if self.state == 'DATA':\n                if command == \".\":\n                    self.state = 'INITIAL'\n                    data_message = \"\\n\".join(self.data_buffer)\n                    logger.info(f\"Received DATA: {data_message}\")\n                    self.data_buffer = []\n                    response = self.responses.get(\"250-DATA\", \"250 ok\")\n                else:\n                    self.data_buffer.append(command)\n                    return\n            else:\n                response = self._get_response(command)\n                if command.upper().startswith(\"QUIT\"):\n                    self.sendLine(response.encode('utf-8'))\n                    log_interaction(self.ip, command, response)\n                    self.transport.loseConnection()\n                    return\n\n            self.sendLine(response.encode('utf-8'))\n            log_interaction(self.ip, command, response)\n        except UnicodeDecodeError as e:\n            logger.error(f\"Unicode decode error: {e}\")\n            self.sendLine(b\"500 Command unrecognized\")\n\n    def _get_response(self, command):\n        \"\"\"\n        Get the appropriate response for a given SMTP command.\n\n        Args:\n            command (str): The SMTP command received.\n\n        Returns:\n            str: The response to the SMTP command.\n        \"\"\"\n        command_upper = command.upper()\n        if command_upper.startswith(\"EHLO\"):\n            return self.responses.get(\"250-EHLO\", f\"250-{domain_name} Hello [{self.ip}]\") + \\\n                   \"\\n250-SIZE 37748736\\n250-PIPELINING\\n250-DSN\\n250-ENHANCEDSTATUSCODES\\n250-STARTTLS\\n250-X-ANONYMOUSTLS\\n250-AUTH NTLM\\n250-X-EXPS GSSAPI NTLM\\n250-8BITMIME\\n250-BINARYMIME\\n250-CHUNKING\\n250 XRDST\"\n        elif command_upper.startswith(\"HELO\"):\n            return self.responses.get(\"250-HELO\", f\"250 {domain_name}\")\n        elif command_upper.startswith(\"MAIL FROM\"):\n            return self.responses.get(\"250-MAIL FROM\", \"250 2.1.0 Sender OK\")\n        elif command_upper.startswith(\"RCPT TO\"):\n            return self.responses.get(\"250-RCPT TO\", \"250 2.1.5 Recipient OK\")\n        elif command_upper.startswith(\"DATA\"):\n            self.state = 'DATA'\n            return self.responses.get(\"354\", \"354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;\")\n        elif command_upper.startswith(\"QUIT\"):\n            return self.responses.get(\"221\", f\"221 {domain_name} Service closing transmission channel\")\n        elif command_upper.startswith(\"AUTH LOGIN\"):\n            username = self._read_base64_response()\n            password = self._read_base64_response()\n            if check_credentials(username, password):\n                return self.responses.get(\"235\", \"235 Authentication successful\")\n            else:\n                return self.responses.get(\"535\", \"535 Authentication failed\")\n        else:\n            return self.responses.get(\"500\", \"500 Command unrecognized\")\n\n    def _read_base64_response(self):\n        \"\"\"\n        Read a base64 encoded response from the client.\n\n        Returns:\n            str: The decoded response (e.g., username or password).\n\n        Note:\n            This method should be implemented to actually decode base64 responses. Currently, it returns a placeholder.\n        \"\"\"\n        return \"username\"  # Replace this with actual base64 decoding logic\n\n    def _format_responses(self, responses):\n        \"\"\"\n        Format the loaded responses into a dictionary.\n\n        Args:\n            responses (list): The list of responses from the AI service.\n\n        Returns:\n            dict: The formatted responses as a dictionary.\n        \"\"\"\n        if isinstance(responses, list):\n            formatted_responses = {}\n            for item in responses:\n                if isinstance(item, dict):\n                    code = item.get('response_code')\n                    description = item.get('description')\n                    if code and description:\n                        formatted_responses[f\"{code}\"] = f\"{code} {description}\"\n                else:\n                    logger.error(f\"Unexpected item format: {item}\")\n            return formatted_responses\n        else:\n            logger.error(f\"Unexpected responses format: {responses}\")\n            return {}\n</code></pre>"},{"location":"reference/smtp_protocol/#smtp_protocol.SMTPProtocol.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the SMTPProtocol instance, setting up AI services and responses.</p> Source code in <code>src/smtp_protocol.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize the SMTPProtocol instance, setting up AI services and responses.\n    \"\"\"\n    self.ip = None\n    self.ai_service = AIService()\n    responses = self.ai_service.load_responses(\"smtp\")\n    logger.debug(f\"Loaded responses: {responses}\")\n    self.responses = self._format_responses(responses)\n    self.state = 'INITIAL'\n    self.data_buffer = []\n    logger.debug(\"SMTPProtocol initialized\")\n</code></pre>"},{"location":"reference/smtp_protocol/#smtp_protocol.SMTPProtocol.connectionMade","title":"<code>connectionMade()</code>","text":"<p>Handle new connections, sending a welcome banner and logging the interaction.</p> Source code in <code>src/smtp_protocol.py</code> <pre><code>def connectionMade(self):\n    \"\"\"\n    Handle new connections, sending a welcome banner and logging the interaction.\n    \"\"\"\n    self.ip = self.transport.getPeer().host\n    banner = self._get_banner()\n    logger.info(f\"Connection from {self.ip}\")\n    self.sendLine(banner.encode('utf-8'))\n    log_interaction(self.ip, 'WELCOME', banner)\n</code></pre>"},{"location":"reference/smtp_protocol/#smtp_protocol.SMTPProtocol.lineReceived","title":"<code>lineReceived(line)</code>","text":"<p>Handle received lines of data, processing SMTP commands and managing state transitions.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>bytes</code> <p>The line of data received.</p> required Source code in <code>src/smtp_protocol.py</code> <pre><code>def lineReceived(self, line):\n    \"\"\"\n    Handle received lines of data, processing SMTP commands and managing state transitions.\n\n    Args:\n        line (bytes): The line of data received.\n    \"\"\"\n    try:\n        command = line.decode('utf-8').strip()\n        logger.info(f\"Received command: {command}\")\n\n        if self.state == 'DATA':\n            if command == \".\":\n                self.state = 'INITIAL'\n                data_message = \"\\n\".join(self.data_buffer)\n                logger.info(f\"Received DATA: {data_message}\")\n                self.data_buffer = []\n                response = self.responses.get(\"250-DATA\", \"250 ok\")\n            else:\n                self.data_buffer.append(command)\n                return\n        else:\n            response = self._get_response(command)\n            if command.upper().startswith(\"QUIT\"):\n                self.sendLine(response.encode('utf-8'))\n                log_interaction(self.ip, command, response)\n                self.transport.loseConnection()\n                return\n\n        self.sendLine(response.encode('utf-8'))\n        log_interaction(self.ip, command, response)\n    except UnicodeDecodeError as e:\n        logger.error(f\"Unicode decode error: {e}\")\n        self.sendLine(b\"500 Command unrecognized\")\n</code></pre>"},{"location":"reference/smtp_protocol/#smtpfactory-class","title":"SMTPFactory Class","text":"<p>The <code>SMTPFactory</code> class is a factory for creating instances of the <code>SMTPProtocol</code> class. It initializes and builds new protocol instances for handling connections.</p>"},{"location":"reference/smtp_protocol/#smtp_protocol.SMTPFactory","title":"<code>smtp_protocol.SMTPFactory</code>","text":"<p>               Bases: <code>Factory</code></p> <p>A factory class for creating instances of SMTPProtocol.</p> Source code in <code>src/smtp_protocol.py</code> <pre><code>class SMTPFactory(protocol.Factory):\n    \"\"\"\n    A factory class for creating instances of SMTPProtocol.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the SMTPFactory.\n        \"\"\"\n        logger.debug(\"SMTPFactory initialized\")\n\n    def buildProtocol(self, addr):\n        \"\"\"\n        Build and return an instance of SMTPProtocol.\n\n        Args:\n            addr (Address): The address of the incoming connection.\n\n        Returns:\n            SMTPProtocol: A new instance of SMTPProtocol.\n        \"\"\"\n        logger.debug(f\"Building SMTP protocol for {addr}\")\n        return SMTPProtocol()\n</code></pre>"},{"location":"reference/smtp_protocol/#smtp_protocol.SMTPFactory.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the SMTPFactory.</p> Source code in <code>src/smtp_protocol.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize the SMTPFactory.\n    \"\"\"\n    logger.debug(\"SMTPFactory initialized\")\n</code></pre>"},{"location":"reference/smtp_protocol/#smtp_protocol.SMTPFactory.buildProtocol","title":"<code>buildProtocol(addr)</code>","text":"<p>Build and return an instance of SMTPProtocol.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>Address</code> <p>The address of the incoming connection.</p> required <p>Returns:</p> Name Type Description <code>SMTPProtocol</code> <p>A new instance of SMTPProtocol.</p> Source code in <code>src/smtp_protocol.py</code> <pre><code>def buildProtocol(self, addr):\n    \"\"\"\n    Build and return an instance of SMTPProtocol.\n\n    Args:\n        addr (Address): The address of the incoming connection.\n\n    Returns:\n        SMTPProtocol: A new instance of SMTPProtocol.\n    \"\"\"\n    logger.debug(f\"Building SMTP protocol for {addr}\")\n    return SMTPProtocol()\n</code></pre>"},{"location":"reference/pop3/pop3_protocol/","title":"POP3 Protocol","text":""},{"location":"reference/pop3/pop3_protocol/#pop3.pop3_protocol","title":"<code>pop3.pop3_protocol</code>","text":""},{"location":"reference/pop3/pop3_states/","title":"POP3 Protocol","text":""},{"location":"reference/pop3/pop3_states/#pop3.pop3_states","title":"<code>pop3.pop3_states</code>","text":""},{"location":"reference/pop3/pop3_states/#pop3.pop3_states.handle_authorization","title":"<code>handle_authorization(protocol, command)</code>","text":"<p>Handle the authorization phase of the POP3 protocol.</p> <p>This function processes USER and PASS commands to authenticate the user. If the user is authenticated, the state transitions to TRANSACTION.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <p>The current protocol instance.</p> required <code>command</code> <code>str</code> <p>The command issued by the client.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A response string indicating the result of the command.</p> Source code in <code>src/pop3/pop3_states.py</code> <pre><code>def handle_authorization(protocol, command):\n    \"\"\"\n    Handle the authorization phase of the POP3 protocol.\n\n    This function processes USER and PASS commands to authenticate the user.\n    If the user is authenticated, the state transitions to TRANSACTION.\n\n    Args:\n        protocol: The current protocol instance.\n        command (str): The command issued by the client.\n\n    Returns:\n        str: A response string indicating the result of the command.\n    \"\"\"\n    command_upper = command.upper()\n    if command_upper.startswith(\"USER\"):\n        protocol.user = command.split(\" \", 1)[1] if len(command.split(\" \", 1)) &gt; 1 else None\n        if protocol.user:\n            logger.debug(f\"USER command received. User set to: {protocol.user}\")\n            return \"+OK User accepted\"\n        return \"-ERR Missing username\"\n    elif command_upper.startswith(\"PASS\"):\n        protocol.passwd = command.split(\" \", 1)[1] if len(command.split(\" \", 1)) &gt; 1 else None\n        if protocol.passwd:\n            protocol.state = 'TRANSACTION'\n            logger.debug(f\"PASS command received. Password set. Moving to TRANSACTION state.\")\n            return \"+OK Password accepted\"\n        return \"-ERR Missing password\"\n    return \"-ERR Please authenticate first\"\n</code></pre>"},{"location":"reference/pop3/pop3_states/#pop3.pop3_states.handle_transaction","title":"<code>handle_transaction(protocol, command)</code>","text":"<p>Handle the transaction phase of the POP3 protocol.</p> <p>This function processes various commands such as STAT, LIST, RETR, DELE, and QUIT, which operate on the emails available in the session.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <p>The current protocol instance.</p> required <code>command</code> <code>str</code> <p>The command issued by the client.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A response string indicating the result of the command.</p> Source code in <code>src/pop3/pop3_states.py</code> <pre><code>def handle_transaction(protocol, command):\n    \"\"\"\n    Handle the transaction phase of the POP3 protocol.\n\n    This function processes various commands such as STAT, LIST, RETR, DELE, and QUIT,\n    which operate on the emails available in the session.\n\n    Args:\n        protocol: The current protocol instance.\n        command (str): The command issued by the client.\n\n    Returns:\n        str: A response string indicating the result of the command.\n    \"\"\"\n    command_upper = command.upper()\n    if command_upper.startswith(\"STAT\"):\n        return _handle_stat(protocol)\n    elif command_upper.startswith(\"LIST\"):\n        return _handle_list(protocol)\n    elif command_upper.startswith(\"RETR\"):\n        return _handle_retr(protocol, command)\n    elif command_upper.startswith(\"DELE\"):\n        return _handle_dele(protocol, command)\n    elif command_upper.startswith(\"QUIT\"):\n        return _handle_quit(protocol, command)\n    return \"-ERR Command unrecognized\"\n</code></pre>"},{"location":"reference/pop3/pop3_utils/","title":"POP3 Utilities","text":""},{"location":"reference/pop3/pop3_utils/#pop3.pop3_utils","title":"<code>pop3.pop3_utils</code>","text":""},{"location":"reference/pop3/pop3_utils/#pop3.pop3_utils.format_responses","title":"<code>format_responses(responses)</code>","text":"<p>Format the raw responses into a structured format for use in the application.</p> <p>This function takes a dictionary of raw responses, typically from a POP3 server or similar service, and restructures them into a more accessible format.</p> <p>Parameters:</p> Name Type Description Default <code>responses</code> <code>dict</code> <p>The raw responses dictionary.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A formatted dictionary where each key-value pair represents a code and its corresponding description.</p> Source code in <code>src/pop3/pop3_utils.py</code> <pre><code>def format_responses(responses):\n    \"\"\"\n    Format the raw responses into a structured format for use in the application.\n\n    This function takes a dictionary of raw responses, typically from a POP3 server or similar service,\n    and restructures them into a more accessible format.\n\n    Args:\n        responses (dict): The raw responses dictionary.\n\n    Returns:\n        dict: A formatted dictionary where each key-value pair represents a code and its corresponding description.\n    \"\"\"\n    if isinstance(responses, dict):\n        formatted_responses = {}\n        for item in responses.get(\"POP3_Responses\", []):\n            code = item.get(\"code\")\n            descriptions = item.get(\"descriptions\", {})\n            for key, description in descriptions.items():\n                formatted_responses[f\"{code} {key}\"] = f\"{code} {description}\"\n        return formatted_responses\n    else:\n        logger.error(f\"Unexpected responses format: {responses}\")\n        return {}\n</code></pre>"},{"location":"reference/pop3/pop3_utils/#pop3.pop3_utils.generate_email_headers","title":"<code>generate_email_headers(email_body)</code>","text":"<p>Generate synthetic email headers for a given email body.</p> <p>This function creates fake email headers including fields such as 'Received', 'Message-ID', 'Date', 'From', and 'To', using random values for IP addresses and IDs. It simulates the email metadata.</p> <p>Parameters:</p> Name Type Description Default <code>email_body</code> <code>dict</code> <p>The body of the email for which headers are to be generated.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A string containing the generated email headers.</p> Source code in <code>src/pop3/pop3_utils.py</code> <pre><code>def generate_email_headers(email_body):\n    \"\"\"\n    Generate synthetic email headers for a given email body.\n\n    This function creates fake email headers including fields such as 'Received', 'Message-ID', 'Date',\n    'From', and 'To', using random values for IP addresses and IDs. It simulates the email metadata.\n\n    Args:\n        email_body (dict): The body of the email for which headers are to be generated.\n\n    Returns:\n        str: A string containing the generated email headers.\n    \"\"\"\n    random_ip = f\"{random.randint(1, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}\"\n    message_id = f\"&lt;{random.randint(1000000000, 9999999999)}.{''.join(random.choices(string.ascii_letters + string.digits, k=5))}@{domain_name}&gt;\"\n    current_time = datetime.datetime.now()\n    received_time = current_time - datetime.timedelta(hours=random.randint(10, 18))\n    message_date_time = current_time - datetime.timedelta(hours=random.randint(5, 8))\n\n    headers = (\n        f\"Received: from {random_ip} by {domain_name} (SMTPD) id {''.join(random.choices(string.ascii_letters + string.digits, k=10))}\\n\"\n        f\"Message-ID: {message_id}\\n\"\n        f\"Date: {message_date_time.strftime('%a, %d %b %Y %H:%M:%S %z')}\\n\"\n        f\"From: {'unknown@domain.com'}\\n\"\n        f\"To: {'recipient@domain.com'}\\n\"\n        f\"Subject: {'No Subject'}\\n\"\n    )\n    return headers\n</code></pre>"},{"location":"reference/pop3/pop3_utils/#pop3.pop3_utils.load_emails","title":"<code>load_emails()</code>","text":"<p>Load email data from predefined JSON files and prepare it for further processing.</p> <p>This function checks specific JSON files for email data, extracts the contents, and formats them into a structure suitable for use within the application. It includes email headers, body, and size.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries, each containing the email headers, body, full content, and size in bytes.</p> Source code in <code>src/pop3/pop3_utils.py</code> <pre><code>def load_emails():\n    \"\"\"\n    Load email data from predefined JSON files and prepare it for further processing.\n\n    This function checks specific JSON files for email data, extracts the contents, and formats them\n    into a structure suitable for use within the application. It includes email headers, body, and size.\n\n    Returns:\n        list: A list of dictionaries, each containing the email headers, body, full content, and size in bytes.\n    \"\"\"\n    email_files = [\n        \"files/email_email1.json\",\n        \"files/email_email2.json\",\n        \"files/email_email3.json\"\n    ]\n    emails = []\n    debug = config.getboolean('server', 'debug', fallback=False)\n    if debug:\n        logger.debug(f\"Checking for email files in directory. Total files to check: {len(email_files)}\")\n    for email_file in email_files:\n        if os.path.exists(email_file):\n            if debug:\n                logger.debug(f\"Found email file: {email_file}\")\n            try:\n                with open(email_file, 'r') as f:\n                    email = json.load(f)\n                    email_size = len(email.get(\"body\", \"\").encode('utf-8'))\n                    email_headers = generate_email_headers(email)\n                    email_content = f\"{email_headers}\\n\\n{email.get('body', '')}\"\n                    emails.append({\n                        'headers': email_headers,\n                        'body': email.get(\"body\", \"\"),\n                        'content': email_content,\n                        'size': len(email_content.encode('utf-8'))\n                    })\n                    if debug:\n                        logger.debug(f\"Email file {email_file} size: {email_size} bytes\")\n            except Exception as e:\n                logger.error(f\"Error reading email file {email_file}: {e}\")\n        else:\n            if debug:\n                logger.debug(f\"Email file not found: {email_file}\")\n    if debug:\n        logger.debug(f\"Total emails loaded: {len(emails)}\")\n    return emails\n</code></pre>"},{"location":"reference/pop3/pop3_utils/#pop3.pop3_utils.log_interaction","title":"<code>log_interaction(ip, command, response)</code>","text":"<p>Log interactions between the client and the server.</p> <p>This function logs the IP address of the client, the command sent, and the server's response.</p> <p>Parameters:</p> Name Type Description Default <code>ip</code> <code>str</code> <p>The IP address of the client.</p> required <code>command</code> <code>str</code> <p>The command issued by the client.</p> required <code>response</code> <code>str</code> <p>The response from the server.</p> required Source code in <code>src/pop3/pop3_utils.py</code> <pre><code>def log_interaction(ip, command, response):\n    \"\"\"\n    Log interactions between the client and the server.\n\n    This function logs the IP address of the client, the command sent, and the server's response.\n\n    Args:\n        ip (str): The IP address of the client.\n        command (str): The command issued by the client.\n        response (str): The response from the server.\n    \"\"\"\n    logger.info(f\"IP: {ip}, Command: {command}, Response: {response}\")\n</code></pre>"}]}